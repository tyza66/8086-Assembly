mov的时候除了可以直接指定一个值存进第一个参数里面，还可以使用mov ax,[] 这样对于DS的相对于[]中的偏移量的位置的数移给AX，并且，方括号里面可以写寄存器名称（只可以是bx）或者像[bx+1]这种表示寄存器中的值+1之后再作为偏移量地址使用，但是不可以使用[bx+cx]这样的加其他寄存器的

在8086 CPU中，默认情况下，内存操作数的段寄存器是由指令类型决定的。对于大多数数据操作指令，默认使用数据段寄存器（DS）。但是，对于指令指针（IP）相关的操作，默认使用代码段寄存器（CS）。
当你使用 [0] 这样的内存操作数时，默认情况下它会引用数据段（DS）中的偏移量为0的位置。也就是说，MOV AX, [0] 实际上是从 DS:0 处读取数据，而不是 CS:0。

SI和DI的功能就是用来寻址的，但是他俩不能分为两个8位寄存器来使用，也可以和bx一样当作偏移量来使用,并且允许使用[bx+si]和[bx+di]的形势来实现偏移寻址，还可以[bx+si+1]或者[bx+di+1]，但是要注意si和di在同一个地址偏移中只可以出现一个

mov本身就可以将寄存器中的值传入寄存器中的某个未知（跟上述内容反过来操作），如果使用[]这种偏移方式往内存中存入数值，这种操作叫做基址变址寻址

bp首先是可以简单看bx的替代 但是区别在于bx是基于ds作为基地址，但是dp基于ss作为基地址（如果没有明显地给出段地址）

寻址的方法分为：直接寻址、寄存器间接寻址、寄存器相对寻址、基址变址寻址、相对基址变址寻址

其中寄存器相对寻址还可以表示为[bx].idata、idata[si]、idata[di]、[bx][idata]
其中基址变址寻址还可以表示为[bx][si]
其中相对基址变址寻址可以表示为[bx].idata[si]、idata[bx][si]

↑总之就是只有一个在外头的时候，在外头那个就是idata


SS是栈段
ES是附加段寄存器
