mov的时候除了可以直接指定一个值存进第一个参数里面，还可以使用mov ax,[] 这样对于DS的相对于[]中的偏移量的位置的数移给AX，并且，方括号里面可以写寄存器名称（只可以是bx）或者像[bx+1]这种表示寄存器中的值+1之后再作为偏移量地址使用，但是不可以使用[bx+cx]这样的加其他寄存器的

在8086 CPU中，默认情况下，内存操作数的段寄存器是由指令类型决定的。对于大多数数据操作指令，默认使用数据段寄存器（DS）。但是，对于指令指针（IP）相关的操作，默认使用代码段寄存器（CS）。
当你使用 [0] 这样的内存操作数时，默认情况下它会引用数据段（DS）中的偏移量为0的位置。也就是说，MOV AX, [0] 实际上是从 DS:0 处读取数据，而不是 CS:0。

SI和DI的功能就是用来寻址的，但是他俩不能分为两个8位寄存器来使用，也可以和bx一样当作偏移量来使用,并且允许使用[bx+si]和[bx+di]的形势来实现偏移寻址，还可以[bx+si+1]或者[bx+di+1]，但是要注意si和di在同一个地址偏移中只可以出现一个

mov本身就可以将寄存器中的值传入寄存器中的某个未知（跟上述内容反过来操作），如果使用[]这种偏移方式往内存中存入数值，这种操作叫做基址变址寻址

bp首先是可以简单看bx的替代 但是区别在于bx是基于ds作为基地址，但是dp基于ss作为基地址（如果没有明显地给出段地址）

寻址的方法分为：直接寻址、寄存器间接寻址、寄存器相对寻址、基址变址寻址、相对基址变址寻址

其中寄存器相对寻址还可以表示为[bx].idata、idata[si]、idata[di]、[bx][idata]
其中基址变址寻址还可以表示为[bx][si]
其中相对基址变址寻址可以表示为[bx].idata[si]、idata[bx][si]

↑总之就是只有一个在外头的时候，在外头那个就是idata


SS是栈段
ES是附加段寄存器

除了以前学到的寄存器以外还有一种寄存器叫做标志寄存器
标志寄存器用来存储相关指令的某些执行结果，用来为CPU执行相关指令提供行为依据，用来控制CPU的相关工作方式
标志寄存器与其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息

OF（溢出标志位）：表示有符号运算结果是否溢出。如果溢出，OF 置位（OV），否则清零（NV）。
CF（进位标志位）：表示无符号运算结果是否产生进位或借位。如果有进位或借位，CF 置位（CY），否则清零（NC）。 进位的位一般会被舍弃
AF（辅助进位标志位）：用于BCD（十进制）运算，表示低4位运算是否产生进位。如果有进位，AF 置位（AC），否则清零（NA）。
ZF（零标志位）：表示运算结果是否为零。如果结果为零，ZF 置位（ZR），否则清零（NZ）。
PF（奇偶标志位）：表示运算结果的所有位中1的个数是否为偶数。如果是偶数，PF 置位（PE），否则清零（PO）。
SF（符号标志位）：表示运算结果的符号。如果结果为负数，SF 置位（NG），否则清零（PL）。
TF（陷阱标志位）：用于单步调试。如果置位，CPU在执行每条指令后会产生一个单步中断。
IF（中断标志位）：控制中断的使能。如果置位，CPU允许中断请求；如果清零，CPU忽略中断请求。
DF是方向标志 用于串的处理 DF=1时每次操作后使SI和DI减小，DF=0时则增大

溢出就是结果超过了可表示范围
进位和溢出的区别在于 进位标志位即使表示成一个无符号数它都已经超过了范围，比如98+98得到的是三个十六进制位 溢出的重点不在于它超没超过范围而在于出现了错误像98+99=-59这种错误的出现