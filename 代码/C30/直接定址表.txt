之前使用的那种标号code、start啥的表示了内存单元地址

其实还有一种标号除了能表示单元地址还能表示内存的长度
就是不写: 直接给变量起别名那种标号 这样除了能表示单元地址还能表示内存的长度
少了冒号多了功能

直接定址（Direct Addressing）是汇编语言中一种基本的寻址方式。通过直接定址，指令中的操作数直接包含要访问的内存地址。直接定址表则是一个包含内存地址的列表，用于简化和组织程序中的数据访问。

以下是对直接定址表的详细介绍：

1. 基本概念
在直接定址方式中，指令中包含一个具体的内存地址，处理器根据这个地址直接访问内存中的数据。例如：

assembly
MOV AX, [1234H]  ; 将内存地址1234H处的数据移动到AX寄存器
在这个例子中，1234H 是一个直接地址，指令直接访问内存中的数据。

2. 直接定址表
直接定址表是一种数据结构，其中包含了一系列内存地址。这些地址可以用于简化数据访问，使程序更易于理解和维护。例如，在程序中定义一个数据段，包含多个内存地址：

assembly
data segment
    addr_table dw 1000H, 2000H, 3000H, 4000H  ; 直接定址表
data ends
在这个例子中，addr_table 是一个直接定址表，包含了四个内存地址。

3. 使用直接定址表
直接定址表可以用于多种场景，例如数据查找、表驱动程序设计等。以下是一个简单的示例，演示如何使用直接定址表：

assembly
assume ds:data

data segment
    addr_table dw 1000H, 2000H, 3000H, 4000H  ; 直接定址表
    value1 db 10H
    value2 db 20H
    value3 db 30H
    value4 db 40H
data ends

code segment
start:
    mov ax, data
    mov ds, ax

    mov si, 2          ; 选择表中的第三个地址
    mov di, addr_table[si*2]  ; 获取第三个地址
    mov al, [di]       ; 访问该地址处的数据

    ; 结束程序
    mov ah, 4CH
    int 21H
code ends
end start
在这个例子中，程序使用直接定址表获取一个地址，并访问该地址处的数据。si寄存器用于选择表中的地址，di寄存器用于存储获取的地址，al寄存器用于存储读取的数据。