# 8086汇编语言教程

### 一、学习的目的和意义

- 许多程序员非常擅长高级语言但是对基础的汇编语言机会没有任何了解，导致很多时候编译出来的程序总会出现很多出乎意料的问题
- 很多嵌入式程序和操作系统都是基于汇编语言进行编写的
- 想要学到更深的境界和机器的思维就需要了解计算机的思考方式，也就是汇编语言
- 一些反编译和计算机安全操作最多涉及的就是汇编语言，也是弥补我童年的一个遗憾
- 很多同学对底层很感兴趣，所以做了这篇教程
- 为了涉及更加高效率的程序和系统，需要对汇编的了解

### 二、机器语言

- 其中蕴含很多历史问题

- 不同厂商或者不同架构出产的CPU所使用的机器语言会有所不同

- 机器语言是比汇编语言更低级的语言，就是一堆二进制数，通常我们不用理解
- 汇编语言会先变化成机器语言给到CPU去处理，汇编语言转换为机器语言的过程就叫汇编
- 机器码写起来非常冗长繁琐，完全不适合人去理解，是计算机的发展历史和硬件架构的共同产物

### 三、环境搭建与说明

- 使用DOSBox作为模拟环境运行
- 指令与数据是应用上的概念
- 在内存或磁盘上，指令和数据没有任何区别，都是二进制信息
- 8986从3号单元读取数据
- 指令、数据、地址 在CPU那边区分的方式是通过走的哪一条总线来判断的
- 地址总线上能存多少个不同的信息，CPU就可以对多少个存储单元进行寻址
- 多少位的电脑决定的就是寻址能力
- 地址总线的宽度决定了CPU的寻址能力
- 数据总线的宽度九二定了CPU与其他器件进行数据传送时的一次数据传送量
- 控制总线总宽度决定了CPU对系统中其他器件的控制的能力
- 内部总线实现CPU内部各个器件之间的联系
- 外部总线实现CPU和主板上其他器件的联系
- 8086CPU有14个寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、DS、ES、PSW
- 8086CPU的所有寄存器都是16位的，可以存放两个字节
- AX、BX、CX、DX通常被称为通用寄存器
- AX的低八位（0-7位）构成了AL寄存器，高八位（8-15位）构成了AH寄存器

### 四、字的概念

- 字的英文就是word
- 16位的寄存器可以存储2个字节的数据，而一个字通常占用1到4个字节，具体取决于编码方式
- 对于大多数编码方式来说，一个字可以轻松地存储在16位的寄存器中
- 8086中，一个字由两个字节组成
- 计算机只会用二进制，人民不喜欢用二进制位，人们用十六进制而不是十进制是因为十六进制和二进制之间有一个很好的转换
- B是二进制的简称、H是16进制的简称
- 常见的bin通常就是二进制文件的文件夹
- 两位十六进制数可以表示一个字节，四个十六进制数刚好表示一个字

### 五、汇编指令

- 汇编语言通常不区分大小写
- 常见的汇编指令就像mov ax,18 这句汇编语言的意思就是将18送入AX 用高级语言表示就是AX=18
- 常见的汇编指令还有add ax,8 这句汇编指令的意思就是将内存器AX中的数值加上8
- 常见的汇编指令还有mov ax,bx 这句汇编指令的意思就是将BX中的数据送入寄存器AX
- 常见的汇编指令还有add ax,bx 这句汇编指令的意思就是将AX和BX的内容相加然后保存在AX中
- 总的来说形式就是前面是操作指令，后面第一个是被操作对象，第二个是操作的参数
- 貌似第一个就是控制指令，第二个就是地址代号，第三个就是数据值
- 上面说的这个用专业的话说就是：操作码（Opcode）、操作数（Operands）、要移动的数据值
- 如果计算结果超出了位数，值不能在指定内存器中完整保存但是CPU 不是真的会丢弃这个值
- 汇编语言学会“会编”就行，主要是要培养出汇编的思维

### 六、物理地址

- 所有内存构成的内存单元在逻辑上是一个一维的线性空间
- 我们将每块空间的唯一的地址称为物理地址
- 16位的CPU具有一下特性：运算一次最多可以处理16位的数据、寄存器最大宽度为16位、寄存器和运算器之间的通路是16位的
- 8086CPU具有以下特性：有20位地址总线，可以传送20位地址，寻址能力为1M、内部为16位结构，只能传送16位的地址，表现的寻址能力却只有64K
- 8086的工程师使用两个16位的地址合成的方案来形成一个20位的物理地址（段地址+偏移地址）
- 段地址和偏移地址传入地址加法器之后经过加法器的运算得到20位的物理真实地址
- 地址加法器运算的方法：真实地址 = 段地址x16 + 偏移地址
- 16进制的数乘以16就是向左移一位
- 乘16的方法其实会导致很多问题，二进制乘以2就左移一位，16进制乘以16就左移一位
- 这样的计算方案的弊端有：内存浪费、复杂性、地址空间限制、性能问题
- 这种思想的对的

### 七、段的概念

- 内存被划分成了一个个的段，每个段有一个段
- 但是事实上内存并没有分段，段的划分来自CPU，由于1086CPU用段地址x16+偏移地址的方式给出内存单元的物理地址，使得我们可以用分段的方法来管理内存
- 段只是我们自己理解的概念，不一定怎么划分，看需要而定
- 在编程的时候可以根据需要，将若干得知连续的内存空间看作一个段，用段地址x16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元
- 段地址x16必然是16的倍数，所以上一个段的起始地址必然是16的倍数
- 偏移地址为16位，16位地址的的寻址的寻址能力为64k，所以一个段的长度最大为64k
- 指定到特定地址的段地址和偏移地址可以有不同组合，换句话说CPU可以用不同的段地址和偏移地址形成同一个物理地址
- 现在如果想表示一个数据存在21F60H内存单元中有这这样两种描述：2000:1F60、内存的2000段中的1F60H单元中

### 八、段寄存器

- 段寄存器就是提供段地址的
- 8086CPU有四个段寄存器：CS、DS、SS、ES
- 当8086CPU想要访问内存的时候，由这四个段寄存器提供内存单元的段地址
- PC交互的步骤如下：首先从CS:IP指向内存单元中读取指令，读取的指令进去指令缓冲器，之后IP = IP + 所读取指令的长度，从而指向下一条指令，最后执行指令，跳转步骤，还原这个过程
- 在8086CPU加电启动的时候，CS被设置为FFFFH，IP被设定为0000H，就是说在开机的时候，CPU从内存中FFFF0H单元中读取指令执行，FFFF0H中的指令就是8086PC机开机后执行的第一条指令
- CPU中程序员能够用指令读写的部件只有寄存器，程序员可以通过修改寄存器中的内容实现对CPU 的控制，CPU从何处执行指令是有CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容来决定CPU执行目标指令
- 修改CS、IP中的内容使用jmp指令    jmp 段地址:偏移地址 jum 2AE3:3
- 可以jmp到某一个合法寄存器使用jmp ax
- `jmp 1000:3`：这是一个远跳转（far jump），它会跳转到段地址 `1000` 和偏移地址 `3` 组合形成的物理地址。这种跳转方式会改变段寄存器和指令指针（IP）的值。
- `jmp 6`：这是一个近跳转（near jump），它只会跳转到当前代码段内的偏移地址 `6`。这种跳转方式只会改变指令指针（IP）的值，而不会改变段寄存器的值。
- 段地址由8086CPU的寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU由4个段寄存器，其走红CS用来存放指令的段地址

### 九、代码段

- 8086PC机，在编程时可以根据需要，将一组内存单元定义为一个段，可以将长度为N的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，这段代码就是用来存放代码的，从而定义了一个代码段
- 如果想让一段内存当作的代码，必须通过CS:IP的形式来指定
- CPU从CS:IP中读取完指令，读取的指令会进入指令缓冲器，读完这条指令之后IP会自动指向下一条指令（IP = IP + “执行完的指令的长度”），之后执行指令缓冲器中刚刚那条指令，不断的重复

### 十、内存访问

- 
